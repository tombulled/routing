Allow routes to be standalone (don't need a router to declare them)
Rename library to 'route' ?
    - No, would cause a name clash
Allow class-based declerations of routers and routes, e.g:
    @router('/api')
    class MyRouter:
        @route('/hello')
        def hello(...):
            ...
Implement multi-dispatch
Create sibling libraries - multi-dispatch, callable module?
Use dataclasses over attrs
Make `Path` its own library, e.g. 'endpoint' ?
Inverse routing implementation is stupid, routing is routing.
    Use custom middleware or pass route to each operation

    E.g:
        @middleware
        def handle(request, call_next):
            route = # get the route
            return call_next(route, ...)
    Or:
        @route
        def my_route(route: Route, foo, bar='bar'):
            ...
HTTP Routing is dirtying this library, not KISS, should be its own library
    'routing' and '?'
    Maybe just define this in salient?
